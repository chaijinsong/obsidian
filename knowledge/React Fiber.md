### **React Fiber 终极解析：架构、调度与性能革新**

---

### **一、背景与动机**

#### **1. 旧架构（Stack Reconciler）的瓶颈**

- **同步递归不可中断**：递归遍历组件树时，一旦开始无法暂停，导致主线程阻塞，复杂应用卡顿。
    
- **无优先级控制**：所有更新同等处理，用户交互等高优先级任务无法及时响应。
    
- **扩展性差**：难以支持异步渲染、服务端渲染优化等现代需求。
    

#### **2. Fiber 的诞生**

React 16 引入 **Fiber 架构**，核心目标是：

- **异步可中断更新**：允许渲染任务分片执行，避免阻塞主线程。
    
- **优先级调度**：根据任务类型（用户输入、动画、数据加载）分配优先级。
    
- **为未来铺路**：支持并发模式（Concurrent Mode）、Suspense 等高级特性。
    

---

### **二、Fiber 的核心设计**

#### **1. Fiber 节点：原子任务单元**

每个组件对应一个 Fiber 节点，是包含以下信息的对象：

javascript

复制

{
  type: ComponentType,      // 组件类型（函数/类组件）
  stateNode: Instance,      // 组件实例或 DOM 节点
  return: Fiber | null,     // 父节点
  child: Fiber | null,      // 第一个子节点
  sibling: Fiber | null,    // 下一个兄弟节点
  pendingProps: Props,      // 待处理的 props
  memoizedProps: Props,     // 当前的 props
  memoizedState: State,     // 当前的 state
  effectTag: Effect,        // 副作用标记（增/删/改）
  nextEffect: Fiber | null, // 下一个副作用节点
  expirationTime: number,   // 任务过期时间（优先级）
  // ...其他调度相关字段
}

#### **2. 链表遍历替代递归**

- **手动控制遍历**：通过 `child`、`sibling`、`return` 指针手动遍历组件树，替代递归调用栈。
    
- **可中断性**：每次处理一个 Fiber 节点后检查剩余时间，若不足则暂停并记录进度。
    

---

### **三、调度机制：时间分片与优先级**

#### **1. 时间分片（Time Slicing）**

- **分片阈值**：默认每个时间片为 **5ms**，通过 `performance.now()` 动态检查耗时。
    
- **中断与恢复**：时间片用完时暂停任务，通过 `MessageChannel` 或 `setTimeout` 调度下一个宏任务继续执行。
    

#### **2. 优先级调度**

React 内部定义多级优先级（从高到低）：

- **Immediate**：同步任务（如 `flushSync`）。
    
- **UserBlocking**：用户交互（点击、输入）。
    
- **Normal**：普通数据更新（如 `useState`）。
    
- **Low**：低优先级任务（如内容预加载）。
    
- **Idle**：空闲任务（如日志上报）。
    

#### **3. 任务抢占与饥饿处理**

- **高优先级抢占**：用户输入等高优先级任务可中断正在执行的低优先级任务。
    
- **饥饿保护**：长期未完成的任务优先级逐步提升，避免无限延迟。
    

---

### **四、双缓冲技术（Double Buffering）**

#### **1. 双树结构**

- **Current 树**：当前屏幕上显示的 Fiber 树。
    
- **WorkInProgress 树**：内存中构建的新 Fiber 树，与 Current 树一一对应。
    

#### **2. 更新流程**

1. **协调阶段**：基于 Current 树构建 WorkInProgress 树，标记变更（副作用）。
    
2. **提交阶段**：将 WorkInProgress 树一次性提交为新的 Current 树，更新 DOM。
    

#### **3. 优势**

- **无中间状态**：DOM 更新原子化，避免渲染不一致。
    
- **复用节点**：未变更的 Fiber 节点直接复用，减少内存开销。
    

---

### **五、中断与恢复机制**

#### **1. 中断点保存**

- **进度记录**：通过 `nextUnitOfWork` 指针保存当前处理的 Fiber 节点。
    
- **原子性保障**：单个 Fiber 节点必须完整处理，中断仅发生在节点之间。
    

#### **2. 恢复执行**

- **链表指针跳转**：直接从 `nextUnitOfWork` 指向的节点继续处理。
    
- **深度优先遍历**：按 `child → sibling → return` 顺序遍历，确保进度连贯。
    

---

### **六、协调与提交阶段**

#### **1. 协调阶段（Reconciliation Phase）**

- **目标**：生成新 Fiber 树并收集副作用。
    
- **操作**：
    
    - 调用 `render` 或函数组件生成子节点。
        
    - Diff 算法对比新旧子节点，标记变更（`effectTag`）。
        
    - 构建副作用链表（`effectList`）。
        
- **特点**：可中断、无 DOM 操作。
    

#### **2. 提交阶段（Commit Phase）**

- **目标**：执行 DOM 更新和生命周期钩子。
    
- **子阶段**：
    
    1. **Before Mutation**：调用 `getSnapshotBeforeUpdate`。
        
    2. **Mutation**：执行 DOM 增删改。
        
    3. **Layout**：调用 `componentDidUpdate`、`useLayoutEffect`。
        
- **特点**：同步执行、不可中断。
    

---

### **七、Fiber 的核心优势**

1. **流畅交互**：高优先级任务即时响应，避免用户输入卡顿。
    
2. **高效渲染**：任务分片与优先级调度，充分利用浏览器空闲时间。
    
3. **扩展性**：为并发模式、Suspense、离线渲染等高级特性奠定基础。
    
4. **内存优化**：双缓冲复用节点，减少 GC 压力。
    

---

### **八、开发建议**

1. **避免重型渲染逻辑**：不在 `render` 中执行复杂计算。
    
2. **优化组件结构**：减少嵌套层级，使用 `React.memo` 或 `PureComponent`。
    
3. **长列表处理**：使用虚拟列表（如 `react-window`）分块渲染。
    
4. **优先级控制**：通过 `startTransition` 标记非紧急更新。
    

---

### **总结**

React Fiber 通过 **可中断的异步渲染**、**优先级调度** 和 **双缓冲机制**，彻底解决了旧架构的阻塞性问题，实现了复杂应用下的流畅交互与高效渲染。其核心思想是将同步不可中断的更新过程，转化为可拆分、可调度、可恢复的异步任务，同时为未来特性提供灵活的基础支持。理解 Fiber 的底层原理，有助于开发者编写高性能 React 应用，并更好地应对复杂场景挑战。















